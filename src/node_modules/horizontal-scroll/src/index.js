import { EventEmitter } from 'events';
import VirtualScroll from 'virtual-scroll';
import raf from 'raf';
import lodash from 'lodash';
import transform from 'prefix';

export default class HorizontalScroll extends EventEmitter {

	constructor(opts) {
		super();

		this._bind();

		// Set default options
		this.options = Object.assign({
			container: opts.container,
			layers: opts.layers,
			isAnimated: opts.isAnimated || false,
			spring: opts.spring  || 0.1,
			skewReducer: opts.skewReducer || 20,
			skewLimit: opts.skewLimit || 30,
			triggerOffsetRatio: opts.triggerOffsetRatio || 0.0,
		}, opts);

		this.vars = {
			windowWidth: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
			totalTimelineWidth: 0,
			scrollValue: 0,
			oldScrollValue: 0,
			scrollTarget: 0,
			scrollLeft: 0,
			scrollRight: 0,
			spring: this.options.spring,
			direction: 0,
			speed: 0,
			speedTarget: 0,
		};

		this.timeline = document.createElement('div');
		this.timeline.setAttribute('class', 'timeline');

		this.cells = [];
		Array.prototype.forEach.call(this.options.layers, layer => {
			let cells = layer.childNodes;
			cells.forEach( cell => {
				if (cell.nodeType === 1) {
					let isInteractive = false;
					let triggerDistance = 0;
					let isCorrupted = false;
					if (cell.hasAttribute('data-interactive-cell')) {
						isInteractive = true;
						if (cell.hasAttribute('data-triggerDistance')) {
							triggerDistance = parseFloat(cell.getAttribute('data-triggerDistance'));
						} else {
							throw 'Interactive cell is missing the triggerDistance.';
						}
						if (cell.hasAttribute('data-corrupted-cell')) {
							isCorrupted = true;
						}
					}
					this.cells.push({
						body: cell,
						triggered: false,
						isInteractive: isInteractive,
						triggerDistance: triggerDistance,
						isCorrupted: isCorrupted});
				}
			});
		});

		this.vs = new VirtualScroll();
		this.transform = transform('transform');

		this.raf = raf;
		this._setUI();
		this.vars.totalTimelineWidth = this.timeline.offsetWidth;
		this._addEvents();
		this.onResize();
		// this._triggerStaticCell(this.cells[0]);

	}

	// PRIVATE

	/**
	 * Biding methods
	 *
	 */
	_bind() {
		this._update = this._update.bind(this);
		this.onResize = this.onResize.bind(this);
	}

	/**
	 * Add all events
	 *
	 */
	_addEvents() {
		this.vs.on(this._onScroll, this);
		this.raf(this._update);
		window.addEventListener('resize', this.onResize);
	}

	/**
	 * Remove all events
	 *
	 */
	_removeEvents() {
		this.vs.off(this._onScroll, this);
		this.raf.cancel(this._update);
		this.raf(this._update);
		window.removeEventListener('resize', this.onResize);
	}

	/**
	 * Set the UI
	 *
	 */
	_setUI() {

		Object.assign(this.timeline.style ,{
			position: 'absolute',
			top: '0',
			left: '0',
			'backface-visibility': 'hidden',
			'will-change': 'transform'
		});

		Object.assign(this.options.container[0].style ,{
			// 'white-space': 'nowrap',
			'position': 'relative',
		});

		Array.prototype.forEach.call(this.options.layers, layer => {
			this.options.container[0].replaceChild(this.timeline, layer);
			this.timeline.appendChild(layer);
		});
		this.options.container[0].appendChild(this.timeline);
	}

	/**
	 * Trigger when user scroll
	 *
	 */

	_triggerCells() {
		this.cells.forEach( cell => {
			if (cell.isInteractive) {
				this._triggerCell(cell);
			}
		});
	}

	_triggerStaticCell(cell) {
		if (cell.body.hasAttribute("data-always-triggered")) {
			let content = cell.body.getElementsByClassName('content')[0];
			let content_children = null;
			if (content !== undefined) {
				content_children = content.children;
			}
			[].forEach.call(content_children, child => {
				// check a child for willCorrupt data attribute
				if (child.hasAttribute('data-willCorrupt')) {
					child.classList.add('corrupted');
				}
				// check if child is img, if so change its src to corrupted image alternative
				if (child.tagName == 'IMG' && child.hasAttribute('data-willCorrupt')) {
					let src = child.src;
					// store file extension of image
					let fileExtension = src.substr(src.length-4, src.length);

					// remove file extension, .png, .jpg etc
					let newSrc = src.slice(0, src.length-4);

					newSrc = newSrc + "-corrupted" + fileExtension;

					child.src = newSrc;
				}
				// check children of the child for willCorrupt data attribute
				// make this recursive please!
				if (child.children !== null) {
					let grand_children = child.children;
					[].forEach.call(grand_children, grand_child => {
						if (grand_child.hasAttribute('data-willCorrupt')) {
							grand_child.classList.add('corrupted');
						}
						// one more level deeper
						if (grand_child.children !== null) {
							let greatgrand_children = grand_child.children;
							[].forEach.call(greatgrand_children, greatgrand_child => {
								if (greatgrand_child.hasAttribute('data-willCorrupt')) {
									greatgrand_child.classList.add('corrupted');
								}
							})
						}
					})
				}
			})
			cell.body.classList.add('corrupted');
		}
	}

	_untriggerStaticCell(cell) {
		if (cell.body.hasAttribute("data-always-triggered")) {
			let content = cell.body.getElementsByClassName('content')[0];
			let content_children = null;
			if (content !== undefined) {
				content_children = content.children;
			}
			[].forEach.call(content_children, child => {
				// check a child for willCorrupt data attribute
				if (child.hasAttribute('data-willCorrupt')) {
					child.classList.remove('corrupted');
				}
				// check if child is img, if so change its src to corrupted image alternative
				if (child.tagName == 'IMG' && child.hasAttribute('data-willCorrupt')) {
					let src = child.src;
					// store file extension of image
					let fileExtension = src.substr(src.length-4, src.length);

					// remove file extension, .png, .jpg etc
					let newSrc = src.slice(0, src.length-14);

					newSrc = newSrc + fileExtension;

					child.src = newSrc;
				}
				// check children of the child for willCorrupt data attribute
				// make this recursive please!
				if (child.children !== null) {
					let grand_children = child.children;
					[].forEach.call(grand_children, grand_child => {
						if (grand_child.hasAttribute('data-willCorrupt')) {
							grand_child.classList.remove('corrupted');
						}
						// one more level deeper
						if (grand_child.children !== null) {
							let greatgrand_children = grand_child.children;
							[].forEach.call(greatgrand_children, greatgrand_child => {
								if (greatgrand_child.hasAttribute('data-willCorrupt')) {
									greatgrand_child.classList.remove('corrupted');
								}
							})
						}
					})
				}
			})
			cell.body.classList.remove('corrupted');
		}
	}

	_triggerCell(cell) {
		let scroll = this.vars.scrollValue;
		let triggerDistance = this.vars.totalTimelineWidth * ( cell.triggerDistance / 100.0);
		// let child = cell.body.getElementByClassName("content");
		let content = cell.body.getElementsByClassName('content')[0];
		let content_children = null;
		if (content !== undefined) {
			content_children = content.children;
		}

		if (scroll > triggerDistance && !cell.triggered) {
			if (cell.isCorrupted && content_children !== null) {
				[].forEach.call(content_children, child => {
					// check a child for willCorrupt data attribute
					if (child.hasAttribute('data-willCorrupt')) {
						child.classList.add('corrupted');
					}
					// check if child is img, if so change its src to corrupted image alternative
					if (child.tagName == 'IMG' && child.hasAttribute('data-willCorrupt')) {
						let src = child.src;
						// store file extension of image
						let fileExtension = src.substr(src.length-4, src.length);

						// remove file extension, .png, .jpg etc
						let newSrc = src.slice(0, src.length-4);

						newSrc = newSrc + "-corrupted" + fileExtension;

						child.src = newSrc;
					}
					// check children of the child for willCorrupt data attribute
					if (child.children !== null) {
						let grand_children = child.children;
						[].forEach.call(grand_children, grand_child => {
							if (grand_child.hasAttribute('data-willCorrupt')) {
								grand_child.classList.add('corrupted');
							}
							if (grand_child.children !== null) {
								let greatgrand_children = grand_child.children;
								[].forEach.call(greatgrand_children, greatgrand_child => {
									if (greatgrand_child.hasAttribute('data-willCorrupt')) {
										greatgrand_child.classList.add('corrupted');
									}
								})
							}
						})
					}
				})
				// add corrupted class to the cell itself
				cell.body.classList.add('corrupted');
			}

			cell.triggered = true;

		} else if (scroll < triggerDistance && cell.triggered) {
			// cell.body.style.backgroundColor = '#ff0011';
			if (cell.isCorrupted && content_children !== null) {
				[].forEach.call(content_children, child => {
					if (child.hasAttribute('data-willCorrupt')) {
						child.classList.remove('corrupted');
					}
					// check if child is img, if so change its src to the original img
					if (child.tagName == 'IMG' && child.hasAttribute('data-willCorrupt')) {
						let src = child.src;
						// store file extension of image
						let fileExtension = src.substr(src.length-4, src.length);

						// remove file extension and '-corrupted'
						let newSrc = src.slice(0, src.length-14);

						newSrc = newSrc + fileExtension;

						child.src = newSrc;
					}
					// check children of the child for willCorrupt data attribute
					if(child.children !== null) {
						let grand_children = child.children;
						[].forEach.call(grand_children, grand_child => {
							if (grand_child.hasAttribute('data-willCorrupt')) {
								grand_child.classList.remove('corrupted');
							}
							if (grand_child.children !== null) {
								let greatgrand_children = grand_child.children;
								[].forEach.call(greatgrand_children, greatgrand_child => {
									if (greatgrand_child.hasAttribute('data-willCorrupt')) {
										greatgrand_child.classList.remove('corrupted');
									}
								})
							}
						})
					}
				})
				cell.body.classList.remove('corrupted');

			}
			cell.triggered = false;

		}

	}

	_onScroll(e) {

		if (e.deltaY > 0) {
			this.vars.direction = 1;
		} else {
			this.vars.direction = -1;
		}

		this.vars.scrollTarget += e.deltaY * -1;
		this.vars.scrollTarget = Math.round(Math.max(this.vars.scrollLeft, Math.min(this.vars.scrollTarget, this.vars.scrollRight)));

		this._triggerCells();
	}

	/**
	 * RAF
	 *
	 */
	_update() {

		// SCROLL VALUE
		this.vars.scrollValue += (this.vars.scrollTarget - this.vars.scrollValue) * this.vars.spring;

		// DELTA
		let delta = this.vars.scrollTarget - this.vars.scrollValue;
		let skew = delta / this.options.skewReducer;
		this.vars.speed = this._clamp(-skew, -this.options.skewLimit, this.options.skewLimit);

		// TRANSFORM
		if (this.options.isAnimated) {
			this.timeline.style[this.transform] = `translate3d(-${this.vars.scrollValue}px, 0 ,0) skewX(${this.vars.speed}deg)`;
		} else {
			this.timeline.style[this.transform] = `translate3d(-${this.vars.scrollValue}px, 0 ,0)`;
		}

		this.vars.oldScrollValue = this.vars.scrollValue;
		this.raf(this._update);
	}



	// }


	/**
	 * CLAMP
	 *
	 */
	_clamp(num, min, max) {
		return Math.min(Math.max(num, min), max);
	}

	// PUBLIC

	/**
	 * Destroy variables and bind events
	 *
	 */

	onResize() {
		this.vars.windowWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
		this.vars.scrollLeft = 0;
		this.vars.scrollRight = this.timeline.getBoundingClientRect().width - window.innerWidth;
	}


	destroy() {
		console.log('destroying');
		this._removeEvents();
	}

	restore() {
		console.log('restoring');
		this._addEvents();
	}

}
